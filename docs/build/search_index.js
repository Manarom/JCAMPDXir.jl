var documenterSearchIndex = {"docs":
[{"location":"JCAMPDXir/#Functions-of-JCAMPDXir","page":"JCAMPDXir","title":"Functions of JCAMPDXir","text":"","category":"section"},{"location":"JCAMPDXir/#JCAMPDXir.JCAMPDXir","page":"JCAMPDXir","title":"JCAMPDXir.JCAMPDXir","text":"This JCAMP-DX (infrared) file format was developed for the exchange of infrared spectra between different laboratories. For general description of format refer to  UIPAC.ORG pdf-file In addition to the spectra themselves, the file also stores metadata containing information about the units of measurement and the conditions under which the spectra were acquired. \n\nJCAMP file content example: \n\n        ##TITLE=1 \n        ##JCAMP-DX=4.24\n        ##DATATYPE=INFRARED SPECTRUM\n        ##XUNITS=1/CM\n        ##YUNITS=TRANSMITTANCE\n        ##YFACTOR=0.00699183\n        ##FIRSTY=11746.3412893072\n        ##NPOINTS=16384\n        ##XYDATA=(X++(Y..Y))\n        0 1680010 821286 2148133 1505245 1537124 1367661 1147725 1134981\n        7.71603 1166853 1213186 1029828 1067595 1135904 1195128 1157134 1150556\n        15.4321 1266743 1164401 1014224 1022338 999780 1138781 1208950 1161258\n        .\n        .\n        ##END=\n\nAccording to JCAMP specifications there are several format for data compression:\n\n        - simple integer: 7.71603 1166853 5213186 -1029828 -1067595 (y-data  decoded as integer numbers)\n        - PAC: 7.71603+1166853+5213186-1029828-1067595 (signs are used as delimiters)\n         -SQZ: 7.71603A166853E213186a029828a067595 (signs are converted according to [`SQZ_digits`](@ref))\n         -DIF: 7.71603 1166853 M046333 o243014 l7767 (all data chunk except the first one represent relative \n                shift of the value with respect to the previous one)\n         -DUP:  in this mode all duplicated y- values are replaced with a single letter according to [`DUP_digits`](@ref)\n                these values show the number of duplications, DUP mode can be combined with DIF-mode\n\n\n\n\n\n","category":"module"},{"location":"JCAMPDXir/#Core.Type-Tuple{AbstractString}","page":"JCAMPDXir","title":"Core.Type","text":"(::Type{SQZ})(s::AbstractString)\n\nAll types are callable on a string and use string conversion to add delimiters between the data chunks When line decoding is of Unspecified_Line before converting the string, there is an additional operation  to get the string type in run-time\n\n\n\n\n\n","category":"method"},{"location":"JCAMPDXir/#Core.Type-Union{Tuple{AbstractString}, Tuple{T}} where T<:JCAMPDXir.Decoding","page":"JCAMPDXir","title":"Core.Type","text":"(::Type{T})(s::AbstractString) where T<:Decoding\n\nBy default, all chunks and line decoding do nothing to the string line \n\n\n\n\n\n","category":"method"},{"location":"JCAMPDXir/#JCAMPDXir.DATAline","page":"JCAMPDXir","title":"JCAMPDXir.DATAline","text":"DATAline type specifies the data organization patter viz XY...XY or XY...Y\n\n\n\n\n\n","category":"type"},{"location":"JCAMPDXir/#JCAMPDXir.DataBuffer","page":"JCAMPDXir","title":"JCAMPDXir.DataBuffer","text":"DataBuffer is an intermediate container for data parsed from each string\n\n\n\n\n\n","category":"type"},{"location":"JCAMPDXir/#JCAMPDXir.Decoding","page":"JCAMPDXir","title":"JCAMPDXir.Decoding","text":"Types for decoding of both lines and chunks, line and chunk typisation is used \nto dispatch during parsing\n\n\n\n\n\n","category":"type"},{"location":"JCAMPDXir/#JCAMPDXir.JDXblock","page":"JCAMPDXir","title":"JCAMPDXir.JDXblock","text":"Stored parsed data\n\nMust be filled using read! function\n\n\n\n\n\n","category":"type"},{"location":"JCAMPDXir/#JCAMPDXir.JDXblock-Tuple{String}","page":"JCAMPDXir","title":"JCAMPDXir.JDXblock","text":"JDXblock(file_name::String)\n\nCreates an empty JDXblock object from full file name \n\n\n\n\n\n","category":"method"},{"location":"JCAMPDXir/#JCAMPDXir.LineDecoding","page":"JCAMPDXir","title":"JCAMPDXir.LineDecoding","text":"Types for decoding lines and chunk string\n\n\n\n\n\n","category":"type"},{"location":"JCAMPDXir/#JCAMPDXir.No_Line_Decoding","page":"JCAMPDXir","title":"JCAMPDXir.No_Line_Decoding","text":"When there is no line decoding all\n\n\n\n\n\n","category":"type"},{"location":"JCAMPDXir/#JCAMPDXir.Unspecified_Line","page":"JCAMPDXir","title":"JCAMPDXir.Unspecified_Line","text":"When using Unspecified_Line type line type parser looks for the actual type for each line\n\n\n\n\n\n","category":"type"},{"location":"JCAMPDXir/#JCAMPDXir.ValidationPoint","page":"JCAMPDXir","title":"JCAMPDXir.ValidationPoint","text":"    Stores Validation points\n\n\n\n\n\n","category":"type"},{"location":"JCAMPDXir/#JCAMPDXir.addline!-Union{Tuple{ChunkDecoding}, Tuple{LD}, Tuple{B}, Tuple{DataLineType}, Tuple{JCAMPDXir.JDXblock, JCAMPDXir.DataBuffer{DataLineType, B, LD, ChunkDecoding}, String}} where {DataLineType<:JCAMPDXir.XYYline, B, LD, ChunkDecoding}","page":"JCAMPDXir","title":"JCAMPDXir.addline!","text":"addline!(           jdx::JDXblock, \n                    data_buffer::DataBuffer{DataLineType,B,LD,ChunkDecoding},\n                    current_line::String; # index of current data chunk\n                    delimiter=DEFAULT_DELIMITER(DataLineType),\n                    validate_data::Bool=true) where {DataLineType<:XYYline,B,LD,ChunkDecoding}\n\nThis function parses current_line string of file, fills data buffer data_buffer by calling fill_data_buffer! and copies buffer content to x- and y-vector of jdx object JDXblock        - the number of data point (excluding the x-coordinate) in the line      -delimiter data points delimiter used in split function     -validate_data if false, parser ignores all data validations\n\n\n\n\n\n","category":"method"},{"location":"JCAMPDXir/#JCAMPDXir.addline!-Union{Tuple{DataLineType}, Tuple{JCAMPDXir.JDXblock, JCAMPDXir.DataBuffer{DataLineType}, String}} where DataLineType<:JCAMPDXir.XYXYline","page":"JCAMPDXir","title":"JCAMPDXir.addline!","text":"addline!(jdx::JDXblock, \n                    data_buffer::DataBuffer{DataLineType},\n                    current_line::String; # index of current data chunk\n                    delimiter=r\"[,;]\",\n                    validate_data::Bool=true) where DataLineType<:XYXYline\n\nAdds line to XY...XY data\n\n\n\n\n\n","category":"method"},{"location":"JCAMPDXir/#JCAMPDXir.check_data_point!-Union{Tuple{T}, Tuple{DataValidation, T, T, Symbol}, Tuple{DataValidation, T, T, Symbol, Int64}, Tuple{DataValidation, T, T, Symbol, Int64, Int64}} where T","page":"JCAMPDXir","title":"JCAMPDXir.check_data_point!","text":"check_data_point!(dv::DataValidation,\n                                value_checker::T,\n                                value_real::T,\n                                field::Symbol,\n                                point_index::Int=0,\n                                line_index::Int=0) where T\n\nFunction used to check the value, input args:\n\n- dv - [`DataValidation`](@ref) object\n- value_checker - checker value (Usually this value is taken from file headers)\n- value_real - value parsed from file\n- field must be :x , :y (for data vector validation) or one of [`VIOLATION_CRITERIA`](@ref) keys\n- point_index - index of data point (used to form the message if the validation fails)\n- line_index - index of line in file (used to form the message if the validation fails)\n\nIf valuechecker â‰ˆ valuereal doesnt fulfilled\n\n\n\n\n\n","category":"method"},{"location":"JCAMPDXir/#JCAMPDXir.convert!-Union{Tuple{T}, Tuple{AbstractArray, JCAMPDXir.sUnits{T}, JCAMPDXir.sUnits{T}}} where T","page":"JCAMPDXir","title":"JCAMPDXir.convert!","text":"convert!(x::AbstractArray,::sUnits{T},::sUnits{T}) where T\n\nThis functions can be used convert y and x units \n\nsupported x-units names: NANOMETERS,NM,CM-1,MKM,MICROMETERS,1/CM,WAVELENGTH (NM)),CM^-1,WAVELENGTH (UM))\n\nsupported y-units names: ABSORBANCE,A,T,A.U.,TRANSMITTANCE,R,KUBELKA-MUNK,ARBITRARY UNITS,REFLECTANCE\n\nExample\n\njulia> convert!([1,2,3],xUnits(\"MKM\"),xUnits(\"1/cm\"))) \n\n\n\n\n\n","category":"method"},{"location":"JCAMPDXir/#JCAMPDXir.fill_data_buffer!-Union{Tuple{ChunkType}, Tuple{LineDecodingType}, Tuple{B}, Tuple{D}, Tuple{JCAMPDXir.DataBuffer{D, B, LineDecodingType, ChunkType}, Any, Any}, Tuple{JCAMPDXir.DataBuffer{D, B, LineDecodingType, ChunkType}, Any, Any, Any}} where {D, B, LineDecodingType, ChunkType}","page":"JCAMPDXir","title":"JCAMPDXir.fill_data_buffer!","text":"fill_data_buffer!(data_buffer::DataBuffer{D,B,LineDecodingType,ChunkType},\n                                        current_line,\n                                        delimiter, \n                                        chunk_counter=1) where {D,B,\n                                        LineDecodingType,\n                                        ChunkType}\n\nFills data buffer data_buffer from current_line, in current_line all data  chunks should be separated by the delimiter, returns the number of data chunks added  to buffer\n\n\n\n\n\n","category":"method"},{"location":"JCAMPDXir/#JCAMPDXir.find_blocks-Tuple{Any}","page":"JCAMPDXir","title":"JCAMPDXir.find_blocks","text":"find_blocks(file_name)\n\nCounts blocks in file file_name, fills coordinates of blocks start and finish in file lines, returns the vector of JDXblock blocks or a singe block.\n\n\n\n\n\n","category":"method"},{"location":"JCAMPDXir/#JCAMPDXir.generateVectors!-Tuple{JCAMPDXir.JDXblock, Type{<:JCAMPDXir.DATAline}}","page":"JCAMPDXir","title":"JCAMPDXir.generateVectors!","text":"generateVectors!(::JDXblock,::Type{<:DATAline})\n\nGenerates x-vector (XY...Y data format) and precreates y-vectors\n\n\n\n\n\n","category":"method"},{"location":"JCAMPDXir/#JCAMPDXir.get_line_decoding-Tuple{AbstractString}","page":"JCAMPDXir","title":"JCAMPDXir.get_line_decoding","text":"get_line_decoding(s::AbstractString)\n\nReturns line type by searching for specific symbols\n\n\n\n\n\n","category":"method"},{"location":"JCAMPDXir/#JCAMPDXir.has_violations-Tuple{DataValidation}","page":"JCAMPDXir","title":"JCAMPDXir.has_violations","text":"has_violations(dv::DataValidation)\n\nCHeks if there is any data violations\n\n\n\n\n\n","category":"method"},{"location":"JCAMPDXir/#JCAMPDXir.parse_chunk","page":"JCAMPDXir","title":"JCAMPDXir.parse_chunk","text":"parse_chunk(::Type{<:ChunkDecoding},s::AbstractString)\n\nFunctions to parse data chunk \n\n\n\n\n\n","category":"function"},{"location":"JCAMPDXir/#JCAMPDXir.parse_headers!-Tuple{JCAMPDXir.JDXblock, Vector{String}}","page":"JCAMPDXir","title":"JCAMPDXir.parse_headers!","text":"parse_headers!(jdx::JDXblock,headers::Vector{String})\n\ninternal function fills headers dictionary from a vector of strings\n\n\n\n\n\n","category":"method"},{"location":"JCAMPDXir/#JCAMPDXir.parse_headers-Tuple{String}","page":"JCAMPDXir","title":"JCAMPDXir.parse_headers","text":"parse_headers(file::String)\n\nParses headers from JCAMP-DX file, returns dictionary with file headers\n\n\n\n\n\n","category":"method"},{"location":"JCAMPDXir/#JCAMPDXir.prepare_jdx_data","page":"JCAMPDXir","title":"JCAMPDXir.prepare_jdx_data","text":"prepare_jdx_data(x::Vector{Float64},y::Vector{Float64},x_units::String=\"1/CM\",\n                                                y_units::String=\"TRANSMITTANCE\"; kwargs...)\n\nPrepares data to be written using write_jdx_file\n\n\n\n\n\n","category":"function"},{"location":"JCAMPDXir/#JCAMPDXir.read!-Tuple{JCAMPDXir.JDXblock}","page":"JCAMPDXir","title":"JCAMPDXir.read!","text":"read!(jdx::JDXblock; delimiter=nothing,\n                           only_headers::Bool=false,\n                           fixed_columns_number::Bool=true,\n                           fixed_line_decoding::Bool = false,\n                           fixed_chunk_decoding::Bool = false,\n                           validate_data::Bool = true)\n\nfills precreated JDXblock object see JDXblock.\n\n`delimiter` - data chunk delimiters\n`only_headers`  - if true parses only block headers\n`fixed_columns_number`  if true, all lines are supposed to have the same number of chunks\n`fixed_line_decoding` if true, data line decoding (No_Line_Decoding, SQZ,PAC) is supposed  to be the same for all lines (parser obtains decoding from the first line of data)\n`fixed_chunk_decoding` if true, all data chunks decoding (No_Chunk_Decoding,DIF,DUP) is supposed  to be the same for all lines (parser obtains decoding from the first line of data)\n`validate_data` if false: we don't need no validation (if false ignores all data validations specified by JCAMP format)\n\n\n\n\n\n","category":"method"},{"location":"JCAMPDXir/#JCAMPDXir.read_jdx_file-Tuple{String}","page":"JCAMPDXir","title":"JCAMPDXir.read_jdx_file","text":"read_jdx_file(file_name::String;\n            fixed_columns_number::Bool=false,\n            delimiter = nothing,\n            fixed_line_decoding::Bool = false,\n            fixed_chunk_decoding::Bool = false,\n            validate_data::Bool=true)\n\nReads JCAMP-DX file file_name\n\nInput arguments: \n\n`file_name` - full file name\n(optional keyword args) \n`fixed_columns_number` - if it is known that each line in file has the same number of data chunks (coded numbers), this flag can be settled to true\n`delimiter`  - data chunks delimiter (default value is space)\n`fixed_line_decoding` if `true` line decoding type ( PAC,SQZ or no line decoding) is taken only once from the first line of data, otherwise new type is obtained for each line\n`fixed_chunk_decoding` if `true` chunk decoding type ( DIF, DUP, mixed DIFDUP or no chunk decoding) is taken from the first line of data, otherwise new type is obtained for each line    \n`validate_data` turns on internal data checks\n\nUsually setting flag value result in speeding up the data loading process by reducing the allocations etc. If file loading speed is not impoertant optional flags can be remained at defaults\n\nOutput arguments is the  namedtuple (or a vector of namedtuples in the case of multiple blocks) \n\nwith fields:\n\nx - coordinate (wavelength, wavenumber or other)\n\ny - data \n\nheaders - dictionary in \"String => value\" format with headers values, values can be both numbers and strings\n\ndata_validation -  structure of [`DataValidation`](@ref) type\n\n\n\n\n\n","category":"method"},{"location":"JCAMPDXir/#JCAMPDXir.write_jdx_file","page":"JCAMPDXir","title":"JCAMPDXir.write_jdx_file","text":"write_jdx_file(file_name,x::Vector{Float64},y::Vector{Float64},x_units::String=\"1/CM\",\n    y_units::String=\"TRANSMITTANCE\"; kwargs...)\n\nSaves infrared spectrum given as two vectors x and y to JCAMP-DX file file_name. Input vector should be of the same size. Currently the package suppots only (X++(Y..Y)) table data format. JCAMP-DX 4.24 demands 80 symbols per file line of Y-data and 88 total symbols per line. The y-vector is stored in eight columns, thus the total number of points should be a multiple of eight. All last mod(length(y),8) points of y dtaa will not be written to the file. It is preferable that all x-data is sorted in ascending order and spaced uniformly. If it is not the case, or if the units conversion  is envolved, function will automatically interpolate and sort the data on uniformly spaced grid.\n\nx_units  - units of x data, must be one of  NANOMETERS,NM,CM-1,MKM,MICROMETERS,1/CM,WAVELENGTH (NM)),CM^-1,WAVELENGTH (UM))\n\ny_units -  units of y data, must be one of ABSORBANCE,A,T,A.U.,TRANSMITTANCE,R,KUBELKA-MUNK,ARBITRARY UNITS,REFLECTANCE \n\nFurther any keword arguments can be provided, all of them will be written to the head of the file. All keyword arguments appear in the file in uppercase.\n\nMost impostant keywords are \n\nTITLE - the title of the file (it is always on top of the file)\nXUNITS - x data units saved to file,  must be one of  NANOMETERS,NM,CM-1,MKM,MICROMETERS,1/CM,WAVELENGTH (NM)),CM^-1,WAVELENGTH (UM))\nYUNITS - y data units saved to file, must be one of ABSORBANCE,A,T,A.U.,TRANSMITTANCE,R,KUBELKA-MUNK,ARBITRARY UNITS,REFLECTANCE\n\nIf x_units (function's fourth argument) are not equal to the key-word argument XUNITS than the function converts x-values before saving to file see xconvert!\n\nIf y_units (function's fifth argument) are not equal to the key-word argument XUNITS than the function converts y-values before saving to file see yconvert!\n\nExample\n\njulia> using JCAMPDXir\njulia> filename = joinpath(@__DIR__,\"test.jdx\")\njulia> write_jdx_file(filename,[1,2,3,4,5,6,7,8],rand(8),\"MKM\",\"T\",title = \"new file\",XUNIT=\"1/CM\",YUNITS=\"KUBELKA-MUNK\") \n\n\n\n\n\n\n","category":"function"},{"location":"JCAMPDXir/#JCAMPDXir.write_jdx_file-Tuple{Any, JCAMPDXir.JDXblock}","page":"JCAMPDXir","title":"JCAMPDXir.write_jdx_file","text":"write_jdx_file(file_name,jdx::JDXblock; kwargs...)\n\nWrites JDXblock object to file\n\n\n\n\n\n","category":"method"},{"location":"JCAMPDXir/#JCAMPDXir.write_jdx_file-Tuple{JCAMPDXir.JDXblock}","page":"JCAMPDXir","title":"JCAMPDXir.write_jdx_file","text":"write_jdx_file(jdx::JDXblock; kwargs...)\n\nWrites JDXblock object to file\n\n\n\n\n\n","category":"method"},{"location":"JCAMPDXir/#JCAMPDXir.xconvert!-Tuple{AbstractArray, String, String}","page":"JCAMPDXir","title":"JCAMPDXir.xconvert!","text":"xconvert!(x::AbstractArray,input_units::String,output_units::String)\n\nConverts the values of `x` from `input_units` to `output_units`.\nsupported x-units names: NANOMETERS,NM,CM-1,MKM,MICROMETERS,1/CM,WAVELENGTH (NM)),CM^-1,WAVELENGTH (UM))\n\nExample\n\njulia> xconvert!([1,2,3],\"MKM\",xUnits\"1/cm\")) \n\n\n\n\n\n","category":"method"},{"location":"JCAMPDXir/#JCAMPDXir.yconvert!-Tuple{AbstractArray, String, String}","page":"JCAMPDXir","title":"JCAMPDXir.yconvert!","text":"yconvert!(y::AbstractArray,input_units::String,output_units::String)\n\nConverts the values of y from input_units to output_units. supported x-units names: NANOMETERS,NM,CM-1,MKM,MICROMETERS,1/CM,WAVELENGTH (NM)),CM^-1,WAVELENGTH (UM)) All units can be written both in lower- and in uppercase, T,R and A stay for  a shorthand for TRANSMITTANCE,REFLECTANCE and ABSORBANCE\n\nExample\n\njulia> yconvert!([1,2,3],\"R\",\"KUBELKA-MUNK\")) \n\n\n\n\n\n","category":"method"},{"location":"#JCAMPDXir.jl","page":"Home","title":"JCAMPDXir.jl","text":"","category":"section"},{"location":"#General-description","page":"Home","title":"General description","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package is designed to read and write infrared spectra saved in JCAMP-DX (infrared) format. It implements the main functionality to read and write JCAMP-DX files according to the 5.01.   ","category":"page"},{"location":"#About-JCAMP-DX-file-format","page":"Home","title":"About JCAMP-DX file format","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For a detailed overview of the JCAMP-DX infrared format, please refer to JCAMP-DX for infrared","category":"page"},{"location":"#Current-state-of-the-package","page":"Home","title":"Current state of the package","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Currently, the package parses JCAMP-DX files written in  (X++(Y..Y)) and (XY...XY) data line formats  in a single or multiple blocks (each block must be embraced in ##TITLE...##END).   Supported data compression methods:","category":"page"},{"location":"","page":"Home","title":"Home","text":"for reading: no data compression, integer comression, SQZ,PAC,DIF and DUP (file can use various combinations of  these compression formats simultaneously)\nfor writing: simple integer compression, the package also supports various x- and y- data units conversions","category":"page"},{"location":"","page":"Home","title":"Home","text":"The package was tested for reading all IR-spectra from python package jcamp","category":"page"},{"location":"#Quick-start","page":"Home","title":"Quick start","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"import Pkg \nPkg.add(\"https://github.com/Manarom/JCAMPDXir.jl.git\")\nusing JCAMPDXir\n(x,y,headers,validation) = read_jdx_file(file_name) \n# to read the file, x - x-values, y - y values, headers - file headers, validation - jcamp specification checks\n\nwrite_jdx_file(x,y,\"MKM\",\"TRANSMITTANCE\") \n# to write x - and y - data vectors of the sama size\n","category":"page"}]
}
