var documenterSearchIndex = {"docs":
[{"location":"JCAMPDXir/#Functions-of-JCAMPDXir","page":"JCAMPDXir","title":"Functions of JCAMPDXir","text":"","category":"section"},{"location":"JCAMPDXir/#JCAMPDXir.JCAMPDXir","page":"JCAMPDXir","title":"JCAMPDXir.JCAMPDXir","text":"This JCAMP-DX (infrared) file format was developed for the exchange of infrared spectra between different laboratories. For general description of format refer to  UIPAC.ORG (pdf file) In addition to the spectra themselves, the file also stores metadata containing information about the units of measurement and the conditions under which the spectra were acquired. A detailed specification of the format is provided via the link. \n\nJCAMP file content example: \n\n        ##TITLE=1 \n        ##JCAMP-DX=4.24\n        ##DATATYPE=INFRARED SPECTRUM\n        ##DATE=2021/10/17\n        ##TIME=11:30\n        ##XUNITS=1/CM\n        ##YUNITS=TRANSMITTANCE\n        ##XFACTOR=1\n        ##YFACTOR=0.00699183\n        ##FIRSTX=0\n        ##LASTX=15801.4671743\n        ##FIRSTY=11746.3412893072\n        ##MAXX=15801.4671743\n        ##MINX=0\n        ##MAXY=3.75371e+006\n        ##MINY=4040.25\n        ##NPOINTS=16384\n        ##XYDATA=(X++(Y..Y))\n        0 1680010 821286 2148133 1505245 1537124 1367661 1147725 1134981\n        7.71603 1166853 1213186 1029828 1067595 1135904 1195128 1157134 1150556\n        15.4321 1266743 1164401 1014224 1022338 999780 1138781 1208950 1161258\n        .\n        .\n        ##END=\n\n\n\n\n\n","category":"module"},{"location":"JCAMPDXir/#Core.Type-Tuple{AbstractString}","page":"JCAMPDXir","title":"Core.Type","text":"(::Type{SQZ})(s::AbstractString)\n\nAll types are callable, when calling on a string \n\n\n\n\n\n","category":"method"},{"location":"JCAMPDXir/#Core.Type-Union{Tuple{AbstractString}, Tuple{T}} where T<:JCAMPDXir.Decoding","page":"JCAMPDXir","title":"Core.Type","text":"(::Type{T})(s::AbstractString) where T<:Decoding\n\nBy default, all chunks and line decoding do nothing to the string line \n\n\n\n\n\n","category":"method"},{"location":"JCAMPDXir/#JCAMPDXir.DATAline","page":"JCAMPDXir","title":"JCAMPDXir.DATAline","text":"DATAline type specifies the data organization patter viz XY...XY or XY...Y\n\n\n\n\n\n","category":"type"},{"location":"JCAMPDXir/#JCAMPDXir.DataBuffer","page":"JCAMPDXir","title":"JCAMPDXir.DataBuffer","text":"DataBuffer is an itermediate container for data parsed from each string\n\n\n\n\n\n","category":"type"},{"location":"JCAMPDXir/#JCAMPDXir.Decoding","page":"JCAMPDXir","title":"JCAMPDXir.Decoding","text":"Types for decoding of both lines and chunks, line and chunk typisation is used \nto dispath during parsing\n\n\n\n\n\n","category":"type"},{"location":"JCAMPDXir/#JCAMPDXir.JDXblock","page":"JCAMPDXir","title":"JCAMPDXir.JDXblock","text":"Stored parsed data\n\nMust be filled using read! function\n\n\n\n\n\n","category":"type"},{"location":"JCAMPDXir/#JCAMPDXir.JDXblock-Tuple{String}","page":"JCAMPDXir","title":"JCAMPDXir.JDXblock","text":"JDXblock(file_name::String)\n\nCreates an empty JDXblock object from full file name \n\n\n\n\n\n","category":"method"},{"location":"JCAMPDXir/#JCAMPDXir.LineDecoding","page":"JCAMPDXir","title":"JCAMPDXir.LineDecoding","text":"Types for decoding lines and shunk string\n\n\n\n\n\n","category":"type"},{"location":"JCAMPDXir/#JCAMPDXir.No_Line_Decoding","page":"JCAMPDXir","title":"JCAMPDXir.No_Line_Decoding","text":"When there is no line decoding all\n\n\n\n\n\n","category":"type"},{"location":"JCAMPDXir/#JCAMPDXir.Unspecified_Line","page":"JCAMPDXir","title":"JCAMPDXir.Unspecified_Line","text":"When using Unspecified_Line type line type parser looks for the actual type for each line\n\n\n\n\n\n","category":"type"},{"location":"JCAMPDXir/#JCAMPDXir.ValidationPoint","page":"JCAMPDXir","title":"JCAMPDXir.ValidationPoint","text":"Stores Validation points\n\n\n\n\n\n","category":"type"},{"location":"JCAMPDXir/#JCAMPDXir.addline!-Union{Tuple{ChunkDecoding}, Tuple{LD}, Tuple{B}, Tuple{DataLineType}, Tuple{JDXblock, JCAMPDXir.DataBuffer{DataLineType, B, LD, ChunkDecoding}, String}} where {DataLineType<:XYYline, B, LD, ChunkDecoding}","page":"JCAMPDXir","title":"JCAMPDXir.addline!","text":"addline!( jdx::JDXblock, \n                    data_buffer::DataBuffer{DataLineType,B,LD,ChunkDecoding},\n                    current_line::String; # index of current data chunk\n                    delimiter=DEFAULT_DELIMITER(DataLineType),\n                    validate_data::Bool=true) where {DataLineType<:XYYline,B,LD,ChunkDecoding}\n\nThis function parses current_line string of file and fills the  parsed data to the y-vector of jdx  object number_of_y_point_per_chunk      - the number of data point (excluding the x-coordinate) in the line      chunk_index index of chunk      delimiter data points delimiter used in split function\n\n\n\n\n\n","category":"method"},{"location":"JCAMPDXir/#JCAMPDXir.addline!-Union{Tuple{DataLineType}, Tuple{JDXblock, JCAMPDXir.DataBuffer{DataLineType}, String}} where DataLineType<:JCAMPDXir.XYXYline","page":"JCAMPDXir","title":"JCAMPDXir.addline!","text":"addline!(jdx::JDXblock, \n                    data_buffer::DataBuffer{DataLineType},\n                    current_line::String; # index of current data chunk\n                    delimiter=r\"[,;]\",\n                    validate_data::Bool=true) where DataLineType<:XYXYline\n\nAdds line to XY...XY data\n\n\n\n\n\n","category":"method"},{"location":"JCAMPDXir/#JCAMPDXir.convert!-Union{Tuple{T}, Tuple{AbstractArray, JCAMPDXir.sUnits{T}, JCAMPDXir.sUnits{T}}} where T","page":"JCAMPDXir","title":"JCAMPDXir.convert!","text":"convert!(x::AbstractArray,::sUnits{T},::sUnits{T}) where T\n\nThis functions can be used convert y and x units \n\nsupported x-units names: NANOMETERS,NM,CM-1,MKM,MICROMETERS,1/CM,WAVELENGTH (NM)),CM^-1,WAVELENGTH (UM))\n\nsupported y-units names: ABSORBANCE,A,T,A.U.,TRANSMITTANCE,R,KUBELKA-MUNK,ARBITRARY UNITS,REFLECTANCE\n\nExample\n\njulia> convert!([1,2,3],xUnits(\"MKM\"),xUnits(\"1/cm\"))) \n\n\n\n\n\n","category":"method"},{"location":"JCAMPDXir/#JCAMPDXir.fill_data_buffer!-Union{Tuple{ChunkType}, Tuple{LineDecodingType}, Tuple{B}, Tuple{D}, Tuple{JCAMPDXir.DataBuffer{D, B, LineDecodingType, ChunkType}, Any, Any}, Tuple{JCAMPDXir.DataBuffer{D, B, LineDecodingType, ChunkType}, Any, Any, Any}} where {D, B, LineDecodingType, ChunkType}","page":"JCAMPDXir","title":"JCAMPDXir.fill_data_buffer!","text":"fill_data_buffer!(data_buffer::Vector{Float64},current_line,delimiter,chunk_counter::Int=1)\n\nAppends data to vector, initial chunk can be of zero size\n\n\n\n\n\n","category":"method"},{"location":"JCAMPDXir/#JCAMPDXir.find_blocks-Tuple{Any}","page":"JCAMPDXir","title":"JCAMPDXir.find_blocks","text":"find_blocks(file_name)\n\nCounts blocks in file file_name, fills coordinates of blocks start and finish in file lines, returns the vector of JDXblock blocks or a singe block.\n\n\n\n\n\n","category":"method"},{"location":"JCAMPDXir/#JCAMPDXir.generateVectors!-Tuple{JDXblock, Type{<:JCAMPDXir.DATAline}}","page":"JCAMPDXir","title":"JCAMPDXir.generateVectors!","text":"generateVectors!(::JDXblock,::Type{<:DATAline})\n\nGenerates x-vector and precreates data vectors\n\n\n\n\n\n","category":"method"},{"location":"JCAMPDXir/#JCAMPDXir.get_line_decoding-Tuple{AbstractString}","page":"JCAMPDXir","title":"JCAMPDXir.get_line_decoding","text":"get_line_decoding(s::AbstractString)\n\nReturns line type by searching for specific symbols\n\n\n\n\n\n","category":"method"},{"location":"JCAMPDXir/#JCAMPDXir.parse_chunk","page":"JCAMPDXir","title":"JCAMPDXir.parse_chunk","text":"parse_chunk(::Type{<:ChunkDecoding},s::AbstractString)\n\nFunctions to parse data chunk, \n\n\n\n\n\n","category":"function"},{"location":"JCAMPDXir/#JCAMPDXir.parse_headers!-Tuple{JDXblock, Vector{String}}","page":"JCAMPDXir","title":"JCAMPDXir.parse_headers!","text":"parse_headers!(jdx::JDXblock,headers::Vector{String})\n\ninternal function fills headers dictionary from a vector of strings\n\n\n\n\n\n","category":"method"},{"location":"JCAMPDXir/#JCAMPDXir.parse_headers-Tuple{String}","page":"JCAMPDXir","title":"JCAMPDXir.parse_headers","text":"parse_headers(file::String)\n\nParses headers from JCAMP-DX file? returns dictionary with file headers\n\n\n\n\n\n","category":"method"},{"location":"JCAMPDXir/#JCAMPDXir.prepare_jdx_data","page":"JCAMPDXir","title":"JCAMPDXir.prepare_jdx_data","text":"prepare_jdx_data(x::Vector{Float64},y::Vector{Float64},x_units::String=\"1/CM\",\n                                                y_units::String=\"TRANSMITTANCE\"; kwargs...)\n\nPrepares data to be written using write_jdx_file\n\n\n\n\n\n","category":"function"},{"location":"JCAMPDXir/#JCAMPDXir.read!-Tuple{JDXblock}","page":"JCAMPDXir","title":"JCAMPDXir.read!","text":"read!(jdx::JDXblock; delimiter=nothing,\n                           only_headers::Bool=false,\n                           fixed_columns_number::Bool=true,\n                           fixed_line_decoding::Bool = false,\n                           fixed_chunk_decoding::Bool = false,\n                           validate_data::Bool = true)\n\nfills precreated JDXblock object see JDXblock.\n\n`delimiter` - data chunk delimiters\n`only_headers`  - if true parses only block headers\n`fixed_columns_number`  if true, all lines are supposed to have the same number of chunks\n`fixed_line_decoding` if true, data line decoding (No_Line_Decoding, SQZ,PAC) is supposed  to be the same for all lines (parser obtains decoding from the first line of data)\n`fixed_chunk_decoding` if true, all data chunks decoding (No_Chunk_Decoding,DIF,DUP) is supposed  to be the same for all lines (parser obtains decoding from the first line of data)\n`validate_data` if false: we don't need no validation\n\n\n\n\n\n","category":"method"},{"location":"JCAMPDXir/#JCAMPDXir.read_jdx_file-Tuple{String}","page":"JCAMPDXir","title":"JCAMPDXir.read_jdx_file","text":"read_jdx_file(file_name::String;\n            fixed_columns_number::Bool=false,\n            delimiter = nothing,\n            fixed_line_decoding::Bool = false,\n            fixed_chunk_decoding::Bool = false,\n            validate_data::Bool=true)\n\nReads JCAMP-DX file file_name\n\nInput arguments: \n\n`file_name` - full file name\n(optional keyword args) \n`fixed_columns_number` - if it is known that each line in file has the same number of data chunks, this flag \n`delimiter`  - data chunks delimiter (default value is space)\n`fixed_line_decoding` if `true` line decoding type ( PAC,SQZ or no line decoding) is taken only once from the first line of data, otherwise new type is obtained for each line\n`fixed_chunk_decoding` if `true` chunk decoding type ( DIF, DUP, mixed DIFDUP or no chunk decoding) is taken from the first line of data, otherwise new type is obtained for each line    \n`validate_data` turns on internal data checks\n\nreturns namedtuple (or a vector of namedtuples in the case of multiple blocks)  with fields:\n\nx - coordinate (wavelength, wavenumber or other)\n\ny - data\n\nheaders - dictionary in \"String => value\" format with headers values \n\ndata_validation, which is the named tuple with\n\n\n\n\n\n","category":"method"},{"location":"JCAMPDXir/#JCAMPDXir.write_jdx_file","page":"JCAMPDXir","title":"JCAMPDXir.write_jdx_file","text":"write_jdx_file(file_name,x::Vector{Float64},y::Vector{Float64},x_units::String=\"1/CM\",\n    y_units::String=\"TRANSMITTANCE\"; kwargs...)\n\nSaves infrared spectrum given as two vectors x and y to JCAMP-DX file file_name. Input vector should be of the same size. Currently the package suppots only (X++(Y..Y)) table data format. JCAMP-DX 4.24 demands 80 symbols per file line of Y-data and 88 total symbols per line. The y-vector is stored in eight columns, thus the total number of points should be a multiple of eight. All last mod(length(y),8) points of y dtaa will not be written to the file. It is preferable that all x-data is sorted in ascending order and spaced uniformly. If it is not the case, or if the units conversion  is envolved, function will automatically interpolate and sort the data on uniformly spaced grid.\n\nx_units  - units of x data, must be one of  NANOMETERS,NM,CM-1,MKM,MICROMETERS,1/CM,WAVELENGTH (NM)),CM^-1,WAVELENGTH (UM))\n\ny_units -  units of y data, must be one of ABSORBANCE,A,T,A.U.,TRANSMITTANCE,R,KUBELKA-MUNK,ARBITRARY UNITS,REFLECTANCE \n\nFurther any keword arguments can be provided, all of them will be written to the head of the file. All keyword arguments appear in the file in uppercase.\n\nMost impostant keywords are \n\nTITLE - the title of the file (it is always on top of the file)\nXUNITS - x data units saved to file,  must be one of  NANOMETERS,NM,CM-1,MKM,MICROMETERS,1/CM,WAVELENGTH (NM)),CM^-1,WAVELENGTH (UM))\nYUNITS - y data units saved to file, must be one of ABSORBANCE,A,T,A.U.,TRANSMITTANCE,R,KUBELKA-MUNK,ARBITRARY UNITS,REFLECTANCE\n\nIf x_units (function's fourth argument) are not equal to the key-word argument XUNITS than the function converts x-values before saving to file see xconvert!\n\nIf y_units (function's fifth argument) are not equal to the key-word argument XUNITS than the function converts y-values before saving to file see yconvert!\n\nExample\n\njulia> using JCAMPDXir\njulia> filename = joinpath(@__DIR__,\"test.jdx\")\njulia> write_jdx_file(filename,[1,2,3,4,5,6,7,8],rand(8),\"MKM\",\"T\",title = \"new file\",XUNIT=\"1/CM\",YUNITS=\"KUBELKA-MUNK\") \n\n\n\n\n\n\n","category":"function"},{"location":"JCAMPDXir/#JCAMPDXir.write_jdx_file-Tuple{Any, JDXblock}","page":"JCAMPDXir","title":"JCAMPDXir.write_jdx_file","text":"write_jdx_file(file_name,jdx::JDXblock; kwargs...)\n\nWrites JDXblock object to file\n\n\n\n\n\n","category":"method"},{"location":"JCAMPDXir/#JCAMPDXir.write_jdx_file-Tuple{JDXblock}","page":"JCAMPDXir","title":"JCAMPDXir.write_jdx_file","text":"write_jdx_file(jdx::JDXblock; kwargs...)\n\nWrites JDXblock object to file\n\n\n\n\n\n","category":"method"},{"location":"JCAMPDXir/#JCAMPDXir.xconvert!-Tuple{AbstractArray, String, String}","page":"JCAMPDXir","title":"JCAMPDXir.xconvert!","text":"xconvert!(x::AbstractArray,input_units::String,output_units::String)\n\nConverts the values of `x` from `input_units` to `output_units`.\nsupported x-units names: NANOMETERS,NM,CM-1,MKM,MICROMETERS,1/CM,WAVELENGTH (NM)),CM^-1,WAVELENGTH (UM))\n\nExample\n\njulia> xconvert!([1,2,3],\"MKM\",xUnits\"1/cm\")) \n\n\n\n\n\n","category":"method"},{"location":"JCAMPDXir/#JCAMPDXir.yconvert!-Tuple{AbstractArray, String, String}","page":"JCAMPDXir","title":"JCAMPDXir.yconvert!","text":"yconvert!(y::AbstractArray,input_units::String,output_units::String)\n\nConverts the values of y from input_units to output_units. supported x-units names: NANOMETERS,NM,CM-1,MKM,MICROMETERS,1/CM,WAVELENGTH (NM)),CM^-1,WAVELENGTH (UM)) All units can be written both in lower- and in uppercase, T,R and A stay for  a shorthand for TRANSMITTANCE,REFLECTANCE and ABSORBANCE\n\nExample\n\njulia> yconvert!([1,2,3],\"R\",\"KUBELKA-MUNK\")) \n\n\n\n\n\n","category":"method"},{"location":"#JCAMPDXir.jl","page":"Home","title":"JCAMPDXir.jl","text":"","category":"section"},{"location":"#General-description","page":"Home","title":"General description","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This lightweight package enables reading and writing of infrared spectra files in the JCAMP-DX format, which typically uses the \".jdx\" file extension. It was written for a specific task and cannot be considered as a complete implementation of all JCAMP-DX format specification. However, it implements the main functionality to read  and write JCAMP-DX files according to the JCAMP-DX=4.24.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The JCAMP-DX format for infrared spectra was created to facilitate the exchange of spectral data between laboratories. For a detailed overview of the JCAMP-DX infrared format, please refer to JCAMP-DX for infrared 4.24. In addition to spectra themselves, JCAMP-DX files also store some metadata containing information about the units of measurement and the conditions under which the spectra were acquired. A detailed specification of the format is provided via the link.  ","category":"page"},{"location":"#Contact","page":"Home","title":"Contact","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To contact me, please do it through the GitHub repository.","category":"page"}]
}
